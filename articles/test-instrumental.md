[содержание](../readme.md)

# Инструментальное тестирование

Основано на [этой][1] статье.

## Введение

До этого момента мы рассматривали только Unit-тесты и только с помощью JUnit. Это очень удобный способ тестировать отдельные методы и классы с использование большого количества различных маленьких тестов.

Но мы также столкнулись и со значительными ограничениями: мы не могли использовать классы Android, не могли тестировать работу с базой данных и другими элементами приложения. Поэтому с помощью JUnit было бы тяжело протестировать работу слоя данных, а протестировать корректность поведения UI вообще невозможно.

К счастью, существует альтернатива тестирования на JUnit, а именно запуск тестов на реальном устройстве. Тестирование на реальном устройстве избавляет нас от предыдущих проблем и позволяет использовать классы Android без дополнительных ухищрений. К тому же в таком случае мы можем использовать все окружение системы, а именно работу с базой данных, работу с файловой системой и все остальное, что нам доступно и при разработке. Поэтому количество проблем, связанных с созданием различных моков уменьшается, и нам для тестирования нужно правильно подменять только ответы сервера.

И есть еще один важный плюс – мы можем тестировать UI-часть приложения, то есть проверять, как именно будет взаимодействовать с приложением конечный пользователь.

Тестирование Android-приложений на устройстве можно разделить условно на 2 вида:

* Инструментальные тесты – это тесты, позволяющие вам использовать классы и методы системы Android для проверки своих модулей.
* UI тесты – это тесты, проверяющие взаимодействие приложения с пользователем и выполняющиеся по принципу черного ящика.
 
## Инструментальные тесты

Инструментальные тесты – это тесты, работающие на реальном устройстве, которые благодаря этому могут использовать все классы и методы системы Android. Они нужны в первую очередь для модульных тестов, когда для тестов требуется использование каких-либо классов Android. Сюда относится тестирование работы с базой данных, с SharedPreferences, с Context и другими классами. Такие тесты мы могли бы применить для тестирования слоя данных, так как в нем выполняется много работы с классами Android (Realm, SharedPreferences).

Рассмотрим процесс создания инструментальных тестов. Во-первых, вам нужно указать в скрипте сборки Runner для инструментальных тестов:

```
android {
    ...
    defaultConfig {
        ...
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    ...
}    
```    

После этого мы можем создать тестовый класс, указав в качестве Runner класс AndroidJUnit4:

```kt
@RunWith(AndroidJUnit4::class)
class MainActivityTest{
```

Этого достаточно, чтобы выполнять тесты на реальном устройстве. Теперь давайте протестируем слой данных, используя инструментальные тесты. И начнем с метода для авторизации. Напомним, как выглядит этот метод:

```kt
fun tryLogIn(login: String, password: String) {
    if (login.trim()=="") {
        authView.showLoginError( ERROR_EMPTY_LOGIN )
    } else if (password.trim()=="") {
        authView.showPasswordError( ERROR_EMPTY_PASSWORD )
    } else {
        // показ прогресс-бара
        authView.showLoading()

        try {
            // в оригинальной статье опущен момент с сохранением токена - это нужно делать тут
            val jsonResp = JSONObject(Factory.repository!!.login("qq", "ww"))
            if(jsonResp.has("status") && jsonResp.getString("status")=="OK") {
                authView.setToken("some token")                    
                authView.successLogin()
            } else {
                authView.showLoginError(ERROR_AUTH)
            }
        } catch (e: Exception){
            authView.showLoginError(ERROR_NETWORK)
        }
        authView.hideLoading()
    }
}
```

Что здесь важно проверить? Основная проверка заключается в том, что текущий токен был сохранен локально в случае успешной авторизации, а ошибка авторизации или ситуация, когда сервер не отвечает, обрабатываются корректно, и мы получаем текст с ошибкой.

При тестировании на устройстве мы можем легко проверить, что данные были сохранены в SharedPreference или другое хранилище. Единственная проблема заключается в том, чтобы корректно подменить работу сервера или сэмулировать нужный нам результат.

Конечно, можно использовать для тестов реальные обращения серверу. Мы обсуждали, что это не лучший подход, но для каких-то ситуаций он подходит (например, для итоговых тестов, чтобы проверить, как приложение будет работать без всяких моков). Если и Android-приложение, и серверная часть разрабатываются вместе, то можно сделать тестовый сервер и настроить его так, чтобы он отдавал нужные ответы в разных тестовых запросах. Но такая настройка больше относится к вопросам серверной части, на стороне приложения достаточно изменять url для серверов. Поэтому такой подход мы рассматривать не будем.

Есть и другие варианты подмены ответов сервера. Репозиторий обращается за данными к сервису ~~Retrofit~~. Он получает сервис ~~Retrofit~~ через статический метод в классе Factory. Мы можем поступить по аналогии с подменой Repository, то есть использовать статический метод для установки значения сервиса ~~Retrofit~~. Так мы поднимаемся как бы на уровень выше с точки зрения подмены ответов.

Как реализовать такой подход? Все аналогично, мы реализуем сервис ~~Retrofit~~ в виде класса и переопределяем метод авторизации:

```kt
class DummyAPI(): API() {
    override fun login(name: String, password: String): String {
        return  if(name=="alice" && password=="qwerty") """{"status":"OK","token":"123"}"""
                else """{"status":"error","error":"user $name not found"}"""
    }
}
```

Здесь мы задаем правило, что для любого пользователя с логином *alice* авторизация будет успешна, а для всех остальных пользователей будет ошибка при вызове этого метода. И теперь мы можем написать следующий тест для сценария успешной авторизации:

TODO: реализовать подмену репозитория (хранилища) и исправить тесты ниже

>Работа с репозиторием еще не сделана, пока пример из оригинальной статьи

```java
@Test
public void testSuccessAuth() throws Exception {
   ApiFactory.setGithubService(new GithubAuthService());
   Authorization authorization = mRepository.auth("root", "12345").toBlocking().first();
   assertEquals(TOKEN, authorization.getToken());

   KeyValueStorage storage = RepositoryProvider.provideKeyValueStorage();
   assertEquals(TOKEN, storage.getToken());
   assertEquals("root", storage.getUserName().toBlocking().first());
}
```

Мы подменяем ответ сервиса ~~Retrofit~~, после чего пытаемся авторизоваться. После авторизации мы проверяем, что все нужные данные были сохранены в настройках. Разумеется, тест для проверки ошибочной авторизации пишется точно также.

Мы снова использовали статический метод для установки значения, как и на прошлой лекции. Этот способ является наиболее простым с точки зрения реализации, но он не лишен недостатков. При таком подходе мы снова не тестируем ответы сервера, а тестируем замоканные модельки, что ухудшает качество тестов. Существуют более продвинутые и удобные способы подмены ответов сервера и реализации принципов IoC. Давайте рассмотрим их.

Хорошим способом изменения ответов сервера является их подмена на уровне *Fuel*. *Fuel* можно настроить таким образом, чтобы он в зависимости от url запроса и от переданных параметров возвращал какой-либо замоканный ответ вместо реального обращения к серверу. Что мы получим в таком случае? Поскольку такая подмена осуществляется уже на уровне сетевого слоя, это никак не затрагивает приложение, а значит, мы тестируем приложение в условиях, максимально близких к реальным.

Посмотрим, как именно можно подменять запросы в *Fuel*. Для этого можно использовать Interceptor, который позволяет перехватывать запросы и обрабатывать их так, как нам нужно. Более того, он позволяет изменять запрос и возвращать результат вообще без обращения к серверу.

Реализуем такой Interceptor. Для этого создадим обычный Interceptor и класс, который будет отвечать за перехват и подмену запросов. Поэтому мы можем написать примерно такой код:

TODO: сюда вставить код для FuelManager

...

Таким образом, мы подменяем окружение, и при этом остальные компоненты приложения этого не видят, что очень удобно и позволяет тестировать приложение в максимально реальных условиях.

На самом деле есть еще два очень важных момента, которые нужно решить. Во-первых, мы рассмотрели только способы подмены успешных ответов, а мы хотели бы тестировать и возникающие ошибки. Здесь не существует простых вариантов, но можно в Interceptor передавать информацию о том, что нужно вернуть ошибку, через какие-то общие данные, например, SharedPreferences. Например, когда мы хотим сэмулировать ошибку, мы можем сохранить текст error вместо токена, и тогда Interceptor поймет, что нужно вернуть ответ с ошибкой:

```java
@NonNull
public Response proceed(@NonNull Request request, @NonNull String path) {
   String token = RepositoryProvider.provideKeyValueStorage().getToken();
   if ("error".equals(token)) {
       return OkHttpResponse.error(request, 400, "Error for path " + path);
   }
   //...
}
```

Во-вторых, и это более серьезная проблема, мы писали весь код для тестов в самом коде приложения, то есть все классы для создания моков, а также JSON-файлы с тестовыми ответами попадут в итоговое приложение, а нам бы этого не хотелось. Наличие таких файлов всегда требует их чистки перед публикацией приложения, а это чревато потенциальными ошибками и багами. Конечно, можно было бы переместить все в тесты и создать метод для подмены экземпляра *Fuel*, но есть намного более удобный способ – *product flavors*.

**Product flavors** позволяют писать нам разный код и использовать разные ресурсы в рамках одного приложения для того, чтобы собирать разные .apk-файлы в зависимости конфигурации. Product flavors расширяют возможности системы сборки gradle.

Мы знаем, что Android Studio поддерживает два типа сборки приложения – debug и release варианты. Первый обычно предназначается для разработки, второй для публикации в Google Play. Но такое разделение позволяет создать только два разных .apk-файла. А что, если нам нужно больше? Самый популярный пример – это платная и бесплатная версии приложения. Например, мы бы хотели в бесплатном приложении показывать рекламу, а в платном убрать ее и добавить некоторые функции. Есть несколько вариантов того, как можно сделать две версии приложения. **Во-первых**, можно сделать два проекта, и использовать в каждом из них только тот код, который нужно. Разумеется, это крайне неудобный и в корне неправильный подход, так как вам приходится дублировать код и вносить одинаковые изменения сразу в два проекта. А если вам нужно не 2 варианта, а 10? Конечно, это не выход. **Во-вторых**, можно в коде выполнять различные проверки и, в зависимости от их выполнения, показывать пользователю нужные экраны. Но это также не очень удачный подход, так как даже в платную версию приложения нам придется добавлять библиотеку для показа рекламы, что увеличит вес приложения. К тому же, такие проверки усложняют саму логику приложения.

В идеале нам бы хотелось писать код в рамках одного проекта, но при этом иметь возможность собрать два .apk-файла с платной и бесплатной версией, избежав сложных проверок.

И такая возможность есть – это **product flavors**. Создать product flavors можно следующим образом:

1. Добавить в build.graddle (app) в секцию android

```
android{
    ...

    flavorDimensions "default"

    productFlavors {
        mock {
            applicationId "ru.kolei.testing.mock"
            versionName "1.0-test"
        }

        prod {
            applicationId "ru.kolei.testing"
            versionName "1.0"
        }
    }
}
```

2. Перенести код в разные product flavors. Если мы откроем папку приложения, то в папке app/src мы увидим папки main, androidTest и test. Сюда же мы должны добавить и новые папки, названия которых соответствуют созданным flavor, то есть mock и prod. В них также создаем папки, соответствующие названиям пакетов (для моего приложения получается *src/mock/java/ru/kolei/testing*) и переносим нужные классы.

Все различие этих product flavors заключается в создаваемом экземпляре Fuel. Поэтому вынесем работу с Fuel в отдельный класс FuelProvider. Этот класс будет создан как во флаворе mock, так и во флаворе prod. Его метод provideClient во флаворе prod будет возвращать обычный Fuel, который всегда будет обращаться к реальному серверу, а во флаворе mock – экземпляр Fuel, который будет использовать моки. И все тесты мы будем запускать в сборке mockDebug.

При таком использовании product flavors вы можете получить еще одно важное преимущество – использование моков для разработки. Вы можете легко оказаться в ситуации, когда вам придется разрабатывать приложение без работающего сервера. И тогда, используя сборку mockDebug, вы сможете писать ваш код полностью на моках, а переключиться на реальный сервер можно будет за счет одной команды в Android Studio, и не нужно будет чистить код от различных проверок.

Теперь, с использованием всех этих знаний, давайте напишем тесты для проверки корректности работы слоя данных для сценариев авторизации. Проверим сценарий успешной авторизации. Для него мы создали следующий JSON-файл:

TODO: написать

Какие тесты нужно дописать для этого метода? Во-первых, нужно проверить, что репозитории корректно получаются с сервера и возвращаются в Observable. Во-вторых, нужно проверить, что данные сохраняются в базу. И в-третьих, нужно написать тест для сценария ошибки и получения из базы закэшированных данных. Все это делается легко, нужно только создать файл, содержащий тело успешного ответа, а также написать тесты на все остальные случаи:

---

Как видно, в первом тесте мы получаем список репозиториев в Observable и проверяем, что нам действительно приходят все данные без ошибок. Во втором тестовом методе мы проверяем, что после выполнения запроса все репозитории были сохранены в базу. Осталось проверить, что в случае ошибки при запросе мы получим данные из базы. Для этого сначала получим данные с сервера и сохраним их в базе, после этого сэмулируем ошибку и попробуем получить данные снова (в таком случае должна произойти ошибка, и мы получим данные из кэша):

---

Таким образом, мы разобрали, как писать Unit-тесты для различных модулей, которые используют зависимости Android. Конечно, можно и нужно писать больше таких тестов на различные случаи, но уже главное, что теперь мы знаем, как писать тесты для таких модулей.

Можно также задаться вопрос о том, зачем вообще нужны тесты на JUnit, когда мы можем писать тесты Unit-тесты с помощью Instrumentation тестов? Основная причина заключается в том, что тесты на JUnit заставляют вас соблюдать определенную архитектуру и не позволяют вам беспорядочно писать весь код в Presenter. Вам нужно писать код аккуратно и чисто. К тому же настроить CI-сервер только на JUnit намного проще, чем на использование эмуляторов или реальных устройств.

Мы рассмотрели способы написания инструментальных тестов и использования их для Unit-тестов. Теперь все модули нашего приложения в отдельности покрыты тестами, и мы можем перейти к рассмотрению других видов тестирования – интеграционному и системному.

[содержание](../readme.md)

[1]: https://www.fandroid.info/instrumental_testing_android_espresso_dagger2/ "Инструментальное и UI тестирование. Espresso. Dagger 2"


[_]: https://www.baeldung.com/kotlin-fuel "Fuel HTTP Library with Kotlin (Request/Response Interceptors)"